package exam;

/**
 *  实战测试题（一）
 *  假设猎聘网有 10 万名猎头顾问，每个猎头顾问都可以通过做任务（比如发布职位），来积累积分，然后通过积分来下载简历
 * 假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：
 * 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
 * 查找积分在某个区间的猎头 ID 列表；
 * 查询积分从小到大排在第 x 位的猎头 ID 信息；
 * 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表
 *
 *
 * 相关章节17 |
 * 跳表：为什么 Redis 一定要用跳表来实现有序集合？
 * 20 | 散列表（下）：为什么散列表和链表经常会一起使用？
 * 25 | 红黑树：为什么工程中都用红黑树这种二叉树？
 *
 * 题目解析这个问题既要通过 ID 来查询，又要通过积分来查询，所以，对于猎头这样一个对象，我们需要将其组织成两种数据结构，才能支持这两类操作
 * 我们按照 ID，将猎头信息组织成散列表
 * 这样，就可以根据 ID 信息快速的查找、删除、更新猎头的信息
 * 我们按照积分，将猎头信息组织成跳表这种数据结构，按照积分来查找猎头信息，就非常高效，时间复杂度是 O(logn)
 * 我刚刚讲的是针对第一个、第二个操作的解决方案
 * 第三个、第四个操作是类似的，按照排名来查询，这两个操作该如何实现呢？我们可以对刚刚的跳表进行改造，
 * 每个索引结点中加入一个 span 字段，记录这个索引结点到下一个索引结点的包含的链表结点的个数
 * 这样就可以利用跳表索引，快速计算出排名在某一位的猎头或者排名在某个区间的猎头列表
 * 实际上，这些就是 Redis 中有序集合这种数据类型的实现原理
 * 在开发中，我们并不需要从零开始代码实现一个散列表和跳表，我们可以直接利用 Redis 的有序集合来完成
 */
public class Exam {
}
